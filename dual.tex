\documentclass[preprint]{sigplanconf}

\usepackage{graphicx}
\usepackage{longtable}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{mdwlist}
\usepackage{txfonts}
\usepackage{xspace}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{multicol}
\usepackage[nodayofweek]{datetime}
\usepackage{etex}
\usepackage[all, cmtip]{xy}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{multicol}
\usepackage{bm}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\xcomment}[2]{\textbf{#1:~\textsl{#2}}}
\newcommand{\amr}[1]{\xcomment{Amr}{#1}}
\newcommand{\roshan}[1]{\xcomment{Roshan}{#1}}

\newcommand{\ie}{\textit{i.e.}\xspace}
\newcommand{\eg}{\textit{e.g.}\xspace}

\newcommand{\lcal}{\ensuremath{\lambda}-calculus}
\newcommand{\G}{\ensuremath{\mathcal{G}}\xspace}

\newcommand{\code}[1]{\lstinline[basicstyle=\small]{#1}\xspace}
\newcommand{\name}[1]{\code{#1}}

\def\newblock{}

\newenvironment{floatrule}
    {\hrule width \hsize height .33pt \vspace{.5pc}}
    {\par\addvspace{.5pc}}

%subcode-inline{bnf-inline} name langRev
%! swap+ = \mathit{swap}^+
%! swap* = \mathit{swap}^*
%! dagger =  ^{\dagger}
%! assocl+ = \mathit{assocl}^+
%! assocr+ = \mathit{assocr}^+
%! assocl* = \mathit{assocl}^*
%! assocr* = \mathit{assocr}^*
%! identr* = \mathit{uniti}
%! identl* = \mathit{unite}
%! dist = \mathit{distrib}
%! factor = \mathit{factor}
%! (o) = \fatsemi
%! (;) = \fatsemi
%! (*) = \times
%! (+) = +

%subcode-inline{bnf-inline} regex \{\{(((\}[^\}])|[^\}])*)\}\} name main include langRev
%! Gx = \Gamma^{\times}
%! G = \Gamma
%! [] = \Box
%! |-->* = \mapsto^{*}
%! |-->> = \mapsto_{\ggg}
%! |--> = \mapsto
%! |- = \vdash
%! ==> = \Longrightarrow
%! <== = \Longleftarrow
%! <=> = \Longleftrightarrow
%! <-> = \leftrightarrow
%! ~> = \leadsto
%! -o = \multimap
%! ::= = &::=&
%! /= = \neq
%! forall = \forall
%! exists = \exists
%! empty = \epsilon
%! langRev = \Pi
%! langRevT = \Pi^{o}
%! langRevEE = \Pi^{\eta\epsilon}
%! theseus = Theseus
%! * = \times

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\conferenceinfo{ICFP'12}{}
\CopyrightYear{}
\copyrightdata{}
\titlebanner{}
\preprintfooter{}

\title{Continuations via Negative Information Flow}
\authorinfo{Roshan P. James}
           {Indiana University}
           {rpjames@indiana.edu}
\authorinfo{Amr Sabry}
           {Indiana University}
           {sabry@indiana.edu}
\maketitle

\begin{abstract}
We show a deep symmetry between functions and delimited continuations,
values and continuations that arises in {{langRev}} in a manner that
is reminiscent of Filinksi's Symmetric \lcal
~\cite{Filinski:1989:DCI:648332.755574}. The symmetry arises by
extending {{langRev}} with a notion of additive duality over the
monoid {{(+, 0)}} by including {{eta}} and {{eps}} operators of
Compact Closed Categories. The resulting dual types, which we denote
{{-b}}, have a time traveling ``backward information flow''
interpretation and allow for the encoding of higher-order function and
iteration via the construction of {{trace}} operators, thereby making
the extended language {{langRevEE}} a Turing-complete reversible
programming language with higher-order functions and first-class
delimited continuations.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\category{D.3.1}{Formal Definitions and Theory}{}
\category{F.3.2}{Semantics of Programming Languages}{}
\category{F.3.3}{Studies of Program Constructs}{Type structure}

\terms
Languages, Theory

\keywords Arrows, Linear logic, Quantum computing, Reversible logic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

We introduced this thesis that computation should be based on isomorphisms
that preserve information~\cite{infeffects}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Value Producers and Consumers}

Consider the following ways of purchasing an item that costs \$20.00:

\begin{enumerate}
\item You produce a \$20.00 bill and give it to the seller.
\item You use a credit card. 
\end{enumerate}
In both cases the seller receives the money immediately but there is a subtle
difference. In the second transation, nobody has yet produced the money that
the seller has received: instead a \emph{debt} is generated and this debt
travels ``backwards'' towards the bank and (hopefully) reconciled there.

Computationally we model the first transaction using essentially the identity
function which receives a \$20.00 bill as input from the buyer and propagates
it on its output to the seller. The second transaction is more
complicated. We model it as shown in the circuit below:

FIGURE

There are two ways to understand this circuit that are both quite
instructive. Let's first examine the type structure of each of the
combinators that comprise the circuit. The first combinator on the right
outputs \$20.00 to the seller. This \$20.00 is produced from nothing so to
speak by generating an equivalent debt that travels backwards. COMPLETE BASED
ON THE FIGURE.

The othe way is to follow the execution. It goes forward in time so to speak,
comes back, and then goes forwards again.

\paragraph*{Continuations.} The idea of using negative types to model
information flowing backwards, demand for values, continuations, etc. goes
back to at Filinski's thesis. We recall these connections below but we first
note that all these systems are complicated because in all these systems
information can be ignored, destroyed, or duplicated. Clearly the possibility
of erasure of information would mean that our credit card transaction is
incorrect. In our work, information is maintained and hence we have a
guarantee that, in a closed program, the debt must be accounted and paid for.

\paragraph*{Filinski.}


\paragraph*{Ariola, Herbelin, and Sabry.} We use subtractive types. Things
are constrained so that the positive and negative values must be used
together. In our new work we have no such constrained, the negative value can
flow anywhere. The entire system guarantees that any closed program would
have to account for it. We don't have to introduce special constraints to
achieve that.

\paragraph*{Focusing, Polarization, etc.}

\paragraph*{Int Construction.}
For a traced monoidal category {{C}} the Int construction produces a
Compact Closed Category called Int {{C}} \cite{joyal1996traced}.
Further we know that the target of the Int construction is isomorphic
to the target of \G construction of Abramsky \cite{Abramsky96:0} from
Haghverdi. However, note that the {{langRevEE}} is not the same as the
image of the Int construction on {{langRevT}}, since the the later
lacks a multiplicative tensor that distrbutes over the additive tensor
in Int {{langRevT}}.

\paragraph*{Recursion.} In our previous work we introduce recursive types and
trace operators. This is dangerous here because infinite loops allow us to
prolong paying the debt for as long as we want.


\paragraph*{GoI machines} 
We can now encode the GoI machine of Mackie \cite{Mackie2011,DBLP:conf/popl/Mackie95}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Additive Duality in {{langRev}} }

%%%%%%%%%%%%%%%
\subsection{Syntax}

%subcode{bnf} include main
% Values, v = () | (v, v) | L v | R v
% Combinators, c &=& iso | c (;) c | c(+)c | c (*) c 
%
% Sequential Contexts, P, F = [] | P:c
% Parallel Contexts, D = [] 
%                     &|& D:(P| [](+)c| F)
%                     &|& D:(P| c(+)[]| F)
%                     &|& D:(P| [] (*) c v| F)
%                     &|& D:(P| [] (*) v c| F)
%                     &|& D:(P| c v (*)  []| F)
%                     &|& D:(P| v c (*) []| F)
%
%
% Machine States  = D[P| c v| F] | D[P| v c| F]
% Start State  = [][[]| v c| []]
% Stop State  = [][P| c v| []]

Combinator reconstruction, {{P[c]}}:
%subcode{opsem} include main
% [](c) '= c
% P:c'(c) '= P(c'(;)c)

%%%%%%%%%%%%%%%%%%%%%
\subsection{Operational Semantics}

The small step semantics present for {{langRev}} below work
symmetrically for forward and backward evaluation.

\begin{itemize}
\item 
Basic reduction of an isomorphism. Note that the evaluation leaves the
adjoint of the combinator behind. This will become important when we
reverse the direction of computation.
%% %subcode{opsem} include main
%% % <P; F; iso v; D>      &|-->& <P; F; v'~ iso{dagger}; D>

%subcode{opsem} include main
% D[P|v iso| F]      &|-->& D[P| iso{dagger} v| F]

\item
Sequencing involves pushing and popping from the Future and Past
continuations:
%subcode{opsem} include main
% D[P|v (c1(;)c2)| F]  &|-->& D[P| v c1| F:c2]
% D[P| c1 v| F:c2] &|-->& D[P:c1| v c2| F]


\item
Parallel composition, captures the current Future and Past and extends
the parallel context.
%subcode{opsem} include main
% D[P|(L v) c1 (+) c2| F] &|-->& D:(P|[](+)c2|F)[ []| v c1| [] ]
% D[P| (R v) c1 (+) c2| F] &|-->& D:(P|c1(+)[]|F)[ []| v c2| [] ]
% D:(P|[](+)c2|F)[P'|c1 v| [] ]  &|-->& D[P|(P'(c1)(+)c2{dagger}) (L v)| F] 
% D:(P|c1(+)[]|F)[P'| c2 v| [] ] &|-->& D[P|(c1{dagger}(+)P'(c2)) (R v)| F]


\item
Similarly for products:
%subcode{opsem} include main
% D[P| (v1, v2) c1 (*) c2| F] &|-->& D:(P| [] (*) v2 c2|F)[ []| v1 c1| [] ]
% D:(P|[] (*) v2 c2|F)[P'| c1 v1| [] ] &|-->& D:(P|P'(c1) v1 (*) []|F)[ []| v2 c2| [] ]
% D:(P|c1 v1(*) []|F)[P'|c2 v2| [] ]  &|-->& D[P|c1(*)P'(c2) (v1, v2)| F]


and symmetrical rules for evaluation along the second branch. 
%subcode{opsem} include main
% D:(P|v1 c1 (*) []|F)[P'| c2 v2| [] ] &|-->& D:(P,[] (*) P'(c2) v2,F)[ []| v1 c1| [] ]
% D:(P|[] (*) c2 v2|F)[P'|c1 v1| [] ] &|-->& D[P |P'(c1) (*) c2 (v1, v2)| F]

The later two rules will be relevant only for reverse execution. 

\end{itemize}


%%%%%%%%%%%%%%%%%
\section{Rules for {{eta}} and {{eps}} }

The operation {{eps}} reverses the direction of a particle by
reversing the world. 

Note that we deviate from the categorical definition of {{eta}} and
{{eps}} slightly in that they swap the order of {{-b}} and {{b}} in
choice of {{eta}}. This however does not affect us, because we deal
with a symmetric category.

\begin{itemize}
\item Grammar
%subcode{bnf} include main
% Values, v = () | (v, v) | L v | R v | -v
% Isomorphisms, iso &=& ... | eta | eps
% Combinators, c &=& iso | c (;) c | c(+)c | c (*) c 

\item
Type judgement.
%subcode{opsem} include main
% eta &: 0 <-> (-b) + b :& eps

%subcode{proof} include main
%@ |- v : b
%@@ |- -v : -b

\item
Operational Semantics.
%subcode{opsem} include main
% D[P| (R v) eps| F]      &|-->&  D{dagger}[F | eps (L (-v))| P]

Note: there is NO reduction rule for {{eta}}. 

\item
The adjoint of a parallel context is defined to be:
%subcode{opsem} include main
% []{dagger} '= []
% (D:(P, [](+)c, F)){dagger} '= D{dagger}:(F, [](+)c{dagger}, P)
% (D:(P, c(+)[], F)){dagger} '= D{dagger}:(F, c{dagger}(+)[], P)
% (D:(P, [](*)c v, F)){dagger} '= D{dagger}:(F, [](*)v c, P)
% (D:(P, [](*)v c, F)){dagger} '= D{dagger}:(F, [](*)c v, P)
% (D:(P, c v(*)[], F)){dagger} '= D{dagger}:(F, v c(*)[], P)
% (D:(P, v c(*)[], F)){dagger} '= D{dagger}:(F, c v(*)[], P)




\end{itemize}


\section{Diagrams}

{{eta}}

\begin{center}
  \includegraphics{diagrams/eta.pdf}
\end{center}

Note that the connective is a {{+}}, hence only one of the branches
may be inhabited at any time. Thus the action of {{eta}} is to
transfer a backward flowing value on one wire to a forward flowing
value on the other wire.

{{eps}}

\begin{center}
  \includegraphics{diagrams/eps.pdf}
\end{center}

Coherence condition

\begin{center}
  \includegraphics{diagrams/coherence.pdf}
\end{center}

Function

\begin{center}
  \includegraphics{diagrams/function.pdf}
\end{center}

Let us use the shorthand {{b1 -o b2 = -b1 + b2}}

Function application

\begin{center}
  \includegraphics{diagrams/apply1.pdf}
\end{center}

\begin{center}
  \includegraphics{diagrams/apply2.pdf}
\end{center}


Function composition

\begin{center}
  \includegraphics{diagrams/compose1.pdf}
\end{center}

\begin{center}
  \includegraphics{diagrams/compose.pdf}
\end{center}



Delimited continuation

\begin{center}
  \includegraphics{diagrams/delimc.pdf}
\end{center}


\paragraph*{Observability.} 
Execution of program is defined by {{c : b1 <-> b2}} when evaluated on
input {{v1 : b1}} gives us a value {{v2 : b2}} on
termination. Execution is well defined only if {{b1}} and {{b2}} are
entirely positive types. Consider the program that

\begin{center}
  \includegraphics{diagrams/shuffle.pdf}
\end{center}

We define observables to be only positive types. The ouputs of
programs that ouput mixed positive and negative types are not
observable.  Also, programs that input mixed positive and negatives
types are not executable.

\subsection{To think about}

\begin{itemize}

\item {{(-b1) * b2}} is not the same as {{b1 * (-b2)}} as there is no
  isomorphism to translate from one to the other.

\item {{-(b1 * b2)}} is not the same as {{b1 * b2}} and is also not
  the same as {{(-b1) * (-b2)}} as there is no isomorphism that goes
  from one to the other.

\item {{-(-b)}} is not the same as {{b}} as there is no isomorphism
  that goes from one to the other.

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\acks This project was partially funded by Indiana University's Office
of the Vice President for Research and the Office of the Vice Provost
for Research through its Faculty Research Support Program.  We also
acknowledge support from Indiana University's Institute for Advanced
Study.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{small}
\bibliographystyle{abbrvnat}
\bibliography{cites}
\end{small}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
