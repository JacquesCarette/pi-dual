\documentclass[sigplan,10pt,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{}
\acmDOI{}
\startPage{1}
\setcopyright{none}
\bibliographystyle{ACM-Reference-Format}

\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{bbm}
\usepackage{wrapfig}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage[references]{agda}
\usepackage{newunicodechar}
\usepackage[nocenter]{qtree}
\usepackage{multicol}
\usepackage{bbold}
\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{quotes}

\usepackage{tikzit}
\input{frac.tikzstyles}

\newunicodechar{‚ä∏}{$\multimap$}
\newunicodechar{Œ†}{$\Pi$}
\newunicodechar{‚âü}{$\mathbin{\stackrel{?}{=}}$}
\newunicodechar{ùïå}{$\mathbb{U}$}
\newunicodechar{ùîπ}{$\mathbb{B}$}
\newunicodechar{ùîΩ}{$\mathbb{F}$}
\newunicodechar{ùïã}{$\mathbb{T}$}
\newunicodechar{ùüò}{$\mathbb{0}$}
\newunicodechar{ùüô}{$\mathbb{1}$}
\newunicodechar{ùüö}{$\mathbb{2}$}
\newunicodechar{‚ãÜ}{${}_*$}
\newunicodechar{‚óã}{$\gcv$}
\newunicodechar{·µ§}{${}_u$}
\newunicodechar{‚äö}{$\fatsemi$}
\newunicodechar{‚ü∑}{$\leftrightarrow$}
\newunicodechar{‚ü∂}{$\longrightarrow$}
\newunicodechar{‚ü™}{$\ll$}
\newunicodechar{‚ü´}{$\gg$}
\newunicodechar{‚äé}{$\uplus$}
\newunicodechar{‚Çó}{$_l$}
\newunicodechar{·µ£}{$_r$}
\newunicodechar{‚Çô}{$_n$}
\newunicodechar{‚ù∞}{$\llparenthesis$}
\newunicodechar{‚ù±}{$\rrparenthesis$}

\newcommand{\alt}{~|~}
\newcommand{\net}{t_\bullet}
\newcommand{\gcv}{\circlearrowright}
\newcommand{\opr}[1]{|#1\rangle\langle#1|}
\newcommand{\inlv}[1]{\ensuremath{\mathit{inj}_1(#1)}}
\newcommand{\inrv}[1]{\ensuremath{\mathit{inj}_2(#1)}}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\oneover}[1]{1/#1}
\newcommand{\pointed}[2]{[#1 \bullet #2]}
\newcommand{\nboxtimes}[2]{\,\,~{^{#1}\boxtimes^{#2}}~\,\,}
\newcommand{\mm}{\texttt{\textminus}}
\newcommand{\pp}{\texttt{+}}
\newcommand{\idv}[3]{#2 \xrightarrow{#1} #3}
\newcommand{\cp}[3]{#1\stackrel{#2}{\bullet}#3}
\newcommand{\idt}[3]{#2 \equiv_{#1} #3}
\newcommand{\idrt}[3]{#3 \equiv_{#1} #2}
\newcommand{\refl}[1]{\textsf{refl}~#1}
\newcommand{\lid}{\textsf{lid}}
\newcommand{\rid}{\textsf{rid}}
\newcommand{\linv}{l!}
\newcommand{\rinv}{r!}
\newcommand{\invinv}{!!}
\newcommand{\assoc}{\circ}
\newcommand{\identlp}{\mathit{unite}_+\mathit{l}}
\newcommand{\identrp}{\mathit{uniti}_+\mathit{l}}
\newcommand{\identlsp}{\mathit{unite}_+\mathit{r}}
\newcommand{\identrsp}{\mathit{uniti}_+\mathit{r}}
\newcommand{\swapp}{\mathit{swap}_+}
\newcommand{\assoclp}{\mathit{assocl}_+}
\newcommand{\assocrp}{\mathit{assocr}_+}
\newcommand{\identlt}{\mathit{unite}_*\mathit{l}}
\newcommand{\identrt}{\mathit{uniti}_*\mathit{l}}
\newcommand{\identlst}{\mathit{unite}_*\mathit{r}}
\newcommand{\identrst}{\mathit{uniti}_*\mathit{r}}
\newcommand{\swapt}{\mathit{swap}_*}
\newcommand{\assoclt}{\mathit{assocl}_*}
\newcommand{\assocrt}{\mathit{assocr}_*}
\newcommand{\absorbr}{\mathit{absorbr}}
\newcommand{\absorbl}{\mathit{absorbl}}
\newcommand{\factorzr}{\mathit{factorzr}}
\newcommand{\factorzl}{\mathit{factorzl}}
\newcommand{\dist}{\mathit{dist}}
\newcommand{\factor}{\mathit{factor}}
\newcommand{\distl}{\mathit{distl}}
\newcommand{\factorl}{\mathit{factorl}}
\newcommand{\distz}{\mathit{absorbr}}
\newcommand{\iso}{\leftrightarrow}
\newcommand{\proves}{\vdash}
\newcommand{\Afun}[1]{\AgdaFunction{#1}}
\newcommand{\Acon}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\Avar}[1]{\AgdaBound{#1}}
\newcommand{\idc}{\mathit{id}\!\!\leftrightarrow}
\newcommand{\Rule}[4]{
\makebox{{\rm #1}
$\displaystyle
\frac{\begin{array}{l}#2 \\\end{array}}
{\begin{array}{l}#3      \\\end{array}}$
 #4}}
\newcommand{\jdg}[3]{#2 \proves_{#1} #3}
\renewcommand{\AgdaCodeStyle}{\footnotesize} %% small}
% 12 pages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Fractional Types}
\subtitle{Expressive and Safe Space Management for Ancilla Bits}
\author{Chao-Hong Chen}
\affiliation{
  \institution{Indiana University}
}

\author{Vikraman Choudhury}
\affiliation{
  \institution{Indiana University}
}

\author{Jacques Carette}
\affiliation{
  \institution{McMaster University}
}

\author{Amr Sabry}
\affiliation{
  \institution{Indiana University}
}

\begin{abstract}
  In reversible and quantum computing, the management of space is
  subject to two broad classes of constraints. First, as is the case
  for general-purpose computation, every allocation must be paired
  with a matching de-allocation. Second, space can only be safely
  de-allocated if its contents are restored to their initial value
  from allocation time. Generally speaking, the state of the art
  provides limited partial solutions that address the first
  constraint by imposing a stack discipline and by leaving the second
  constraint to programmers' assertions.

  We propose a novel approach based on the idea of \emph{fractional
    types}. As a simple intuitive example, allocation of a new boolean
  value initialized to \AgdaInductiveConstructor{false} also creates a value
  $\oneover{\AgdaInductiveConstructor{false}}$ that can be thought of as a garbage
  collection (gc) process specialized to reclaim, and only reclaim,
  storage containing the value $\AgdaInductiveConstructor{false}$. This gc process is a
  first-class entity that can be sliced and diced by combining it with
  other gc processes and decomposing it in smaller
  processes.

  Technically, we formalize this idea in the context of a reversible
  language founded on type isomorphisms, prove its fundamental
  correctness properties, and illustrate its expressiveness using a
  wide variety of examples. The development is backed by a
  fully-formalized Agda implementation.
\end{abstract}

\maketitle

%% for Sec. 4
\input{latex/PiFracDynDefCode.tex}
\input{latex/PiFracDynCode.tex}

%% for Sec. 5
\input{latex/PiMemSemCode.tex}
\input{latex/PiFracMemSemCode.tex}

%% for Sec. 6
\input{latex/J.tex}
\input{latex/PiPointedFracCode.tex}
\input{latex/ExtractionCode.tex}
\input{latex/BooleanCircuitsCode.tex}
\input{latex/PiPointedFracTraceCode.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-0.5\baselineskip}

\section{Introduction}

If quantum field theory is correct (as it so far seems to be) then
information, during any physical process, is neither created nor
destroyed. Landauer~\cite{Landauer:1961,Landauer,bennett1985fundamental},
Bennett~\cite{bennett2010notes,bennett2003notes,Bennett:1973:LRC},
Fredkin~\cite{fredkin1982conservative} and others made compelling
arguments that this physical principle induces a corresponding
computational principle of ``conservation of information.'' This
principle is indeed one of the defining characteristics of quantum
computing and its classical restriction known as reversible computing.

\paragraph*{Quantum and Reversible Computing Based on Type
  Isomorphisms.} The Toffoli gate is known to be universal for
classical reversible circuits~\cite{Toffoli:1980}. Adding just one
gate (the Hadamard gate) produces a universal set of primitives for
quantum circuits~\cite{hadtoffuniv}. The ``only'' difference between
the two circuit models is that quantum circuits can process
superpositions of values (waves) in one step whereas classical
circuits lack this form of parallelism. Most importantly, structurally
the two circuit models are identical and one can derive properties
valid for both families by focusing on the simpler classical model. In
fact, classical reversible computations are often used as
``subroutines'' of quantum computations, i.e., classical reversible
circuits can be applied to either classical inputs or to quantum
inputs.

Instead of using the low-level circuit model of computation,
one can leverage the full force of type theory and category theory by
expressing reversible classical computations as \emph{isomorphisms
  over finite types}~\cite{Fiore:2004,James:2012:IE:2103656.2103667}
or \emph{equivalences over
  groupoids}~\cite{DBLP:conf/esop/CaretteS16}. This perspective is
similarly universal for reversible computation (and can be extended to
quantum computation~\cite{10.1007/978-3-319-89366-2_19}) but with the
advantage of exposing a rich mathematical structure in reversible
computations that we will exploit to solve the ``ancilla problem''
explained next.

\paragraph*{Temporary Storage using Ancilla Bits.} The universality of
the Toffoli gate for classical reversible computing and the
universality of the Toffoli-Hadamard gates for quantum computing come
with a catch and should
not distract from efficiency and safety concerns. The theorems proving
universality (i) assume that temporary storage (often called
\emph{ancilla bits}) may be used~\cite{Toffoli:1980}, and (ii) that
this temporary storage is returned to its initial state before
de-allocation. Indeed if no temporary storage is allowed, the Toffoli
gate is not
universal~\cite{aaronson_et_al:LIPIcs:2017:8173,DBLP:journals/corr/Xu15e}.
And, as would be expected, the more temporary storage is allowed, the
more efficient certain computations can become.

More fundamentally, the condition requiring that the temporary storage
is only de-allocated when returned to its initial condition is a
safety condition. Violating this condition destroys the symmetry
between input and output, making the circuits irreversible and, in
the quantum model, causes decoherence that may destroy the quantum
state. As reviewed in Sec.~\ref{sec:examples}, ancilla bits have a
number of other critical applications, yet are poorly supported in
current reversible and quantum programming languages making them a
common source of bugs.

\paragraph*{Conservation of Information and Negative Entropy.}
The conventional theory of
communication~\cite{Shannon1948} views a type with $N$ values as
an abstract system that has $N$ distinguishable states; the
amount of information contained in each state is $\log{N}$. This
entropy is a measure of information which materializes itself in
memory or bandwidth requirements when storing or transmitting elements
of this type. Thus a type with 8 elements needs 3 bits of memory for
storage or 3 bits of bandwidth for communication. The information
contained in a composite state, by definition of the logarithm,
is the sum of the information contained in its constituents. For example,
the type $A \times B$ where $A$ has two elements and $B$ has three elements can
be thought of a composite system consisting of two independent
unrelated subsystems.  Each state of the composite system therefore
contains $\log{(2*3)} = \log{2} + \log{3}$ bits, the sum of
the information contained in each subsystem. If we could imagine a
\emph{fractional type} $\frac{1}{A}$, this type would introduce
negative entropy. For example, a type with ``cardinality''
$\frac{1}{8}$ has entropy $\log{\frac{1}{8}} = -3$. It is natural to
interpret this negative entropy just like we interpret ``negative
money,'' as a resource (space or bandwidth) to be repaid (reclaimed)
by some other part of the system. Indeed, we will introduce such
fractional types and use them to represent ``garbage collection
processes'' that reclaim temporary storage. Just like in the case of
``negative money'' it is critical that these fractional types be
linearly used, i.e., they cannot be duplicated or erased: this
property is automatically enforced in a reversible
computational model.

\paragraph*{Outline.} We solve the ancilla problem in reversible and
quantum computation using a novel concept: \emph{fractional types}. In
the next section, we introduce the problem of ancilla, motivate its
importance, and explain the limitations of current solutions. In
Sec.~\ref{sec:pi}, we review existing work%
~\cite{rc2011,DBLP:conf/esop/CaretteS16,rc2012,James:2012:IE:2103656.2103667}
that introduces a reversible programming language built using type
isomorphisms.  Although the concept of fractional types might apply to
general-purpose languages (after some adaptation), its natural
technical definition exploits symmetries present in the categorical
model of type isomorphisms. We present such a definition in
Sec.~\ref{sec:dyn} which captures and illustrates the main novelties
of fractional types and their runtime representations as first-class
gc processes. This definition allows allocation and de-allocation of
ancillae in patterns beyond the scope model but, like existing
stack-based solutions, still requires a runtime check to verify the
safety of de-allocation.
%% \ednote{JC: I don't understand the previous sentence. What does
%% ``this presentation'' refer to?  The paper as a whole, or the
%% details of the fractional types? There is also a tension between
%% ``partially solves'' and ``more general and more expressive'' which
%% might very well be true, but makes for a very vague sentence.}
To make the arguments regarding memory
management explicit, Sec.~\ref{sec:space} presents an abstract machine
with a heap component that grows and shrinks as ancillae are allocated
and de-allocated via garbage collection. In Sec.~\ref{sec:dep} we
lift ``plain'' programs manipulating ancillae to the type system in
order to exploit the power of dependent types to guarantee, for the
first time, the condition necessary for safe de-allocation of
ancillae. Technically this solution requires the introduction of
pointed types on top of which we define both a monad and comonad of
singleton types. The tracking of ancillae value is done within the
type system via singleton types. A number of examples exploiting
the singleton-based type system are presented to demonstrate the full
expressiveness of reasoning about fractional types. The type safety proofs demonstrate
that plain (but guaranteed safe)
programs can be extracted and executed without errors or runtime
checks in the conventional type system. The last section concludes
with a discussion of related work and a summary of our results.

The paper includes a number of languages that express different
points. The three most important languages and their relationships are
highlighted in this diagram:

\vspace{-\baselineskip}

\begin{center}
\input{lang.tikz}
\end{center}

\vspace{-1.5\baselineskip}

\noindent The language $\Pi$ is the base language of type isomorphisms. It is
defined in Sec. 3, and first extended with fractional types in
Sec. 4.4. This extension $\Pi/D$ requires a runtime check to ensure
safe de-allocation. In Sec. 6.2, $\Pi$ is independently extended to
$\Pi/\bullet$ which uses singleton types to keep track of the value of
ancillae. In Sec. 6.3, we show that $\Pi/D$ programs extracted from
$\Pi/\bullet$ are safe without the runtime checks associated with
de-allocation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ancilla Bits}
\label{sec:examples}

Restricting a reversible (classical or quantum) circuit to use no
ancillae is like restricting a Turing machine to use no memory other
than the $n$ bits used to represent the
input~\cite{aaronson_et_al:LIPIcs:2017:8173}. As such a restriction
disallows countless computations for trivial reasons, reversible and
quantum models of computation have, since their inception, included
management for scratch storage in the form of ancilla
bits~\cite{Toffoli:1980} with the fundamental restriction that such
bits must be returned to their initial states before being safely
reused or de-allocated.

%%%
\subsection{Applications}

Beyond computability and efficiency reasons, ancillae have found a
wide range of interesting applications.

\paragraph*{Quantum blackboxes and Phase Kickback Trick.} Consider a
small database with four elements $a$, $b$, $c$, and $d$. We are given
a function $f$ that maps every element to $0$ except for one element
of interest, e.g., $f(a)=1$ and $f(b)=f(c)=f(d)=0$. In the worst case,
finding the element of interest might require applying $f$ to every
element of the database. In the quantum world we can find the element
much more efficiently using Grover's
algorithm~\cite{Grover:1996:FQM:237814.237866}. We start by building
an equally weighted superposition of the elements:
$\frac{1}{2}\ket{a}+\frac{1}{2}\ket{b}+\frac{1}{2}\ket{c}+\frac{1}{2}\ket{d}$
and operate concurrently of the superposition as follows:

\[\begin{array}{l}
\frac{1}{2}\ket{a}+\frac{1}{2}\ket{b}+\frac{1}{2}\ket{c}+\frac{1}{2}\ket{d}\\ [1.5ex]
\qquad\Rightarrow  \textrm{phase kickback} \\ [1.5ex]
-\frac{1}{2}\ket{a}+\frac{1}{2}\ket{b}+\frac{1}{2}\ket{c}+\frac{1}{2}\ket{d}\\ [1.5ex]
\qquad\Rightarrow  \textrm{diffusion} \\ [1.5ex]
 (\frac{1}{2}-(-\frac{1}{2}))\ket{a}+(\frac{1}{2}-\frac{1}{2})\ket{b}+(\frac{1}{2}-\frac{1}{2})\ket{c}+(\frac{1}{2}-\frac{1}{2})\ket{d})\\ [1.5ex]
\qquad\Rightarrow  \textrm{simplification} \\ [1.5ex]
\ket{a}
\end{array}\]

The question, which arises repeatedly in quantum computation, is how
to implement operations such as phase kickback. Essentially we want to
concurrently perform the following action on every element of the
superposition:
\[\begin{array}{l}
  \textbf{if}~\textit{current-element}=\ket{a} \\
  \textbf{then}~\textit{negate} \\
  \textbf{else}~\textit{identity}
\end{array}\]
In the quantum world, na\"\i vely attempting to test whether the
current element is equal to $\ket{a}$ by performing a measurement would
destroy the quantum superposition, defeating the entire algorithm.

Ancilla bits offer a solution.  In the words of
Matuschak and Nielsen~\cite{howgrover}, the idea is as follows:
\begin{quote}
  There's a rough heuristic worth noting here, which is that you can
  often convert \verb|if-then| style of thinking into quantum
  circuits. You introduce an ancilla qubit to store the outcome of
  evaluating the \verb|if| condition. And then depending on the state
  of the ancilla, you perform the appropriate state
  manipulation. Finally, when possible you reverse the initial
  computation, resetting the ancilla to its original state so you can
  subsequently ignore it.
\end{quote}
%% \ednote{Would it make sense to explicitly mention CNOT here?}

\paragraph*{Quantum Error Correction.}
Quantum error correction requires the ability to replicate the state of a
qubit onto a number of qubits~\cite[Ch.~3]{NAP25196}. This is impossible to do
directly, by the no-cloning
theorem~\cite{park1970concept,wootters1982single,dieks1982communication}. Again
ancilla qubits solve the problem: because they start in a known
initial state, it is possible to create a simple circuit that makes
their output state match a protected qubit without knowing or
disturbing the protected qubit. Chong et al.~\cite{sigarchblog}
illustrate the idea with a simple example:
\begin{quote}
Consider a 3-qubit quantum majority code in which a logical ``0'' is
encoded as ``000'' and a logical ``1'' is encoded as ``111.''  Just as with
a classical majority code, a single bit-flip error can be corrected by
restoring to the majority value.  Unlike a classical code, however, we
cannot directly measure the qubits else their quantum state will be
destroyed.  Instead, we measure syndromes from each possible pair of
qubits by interacting them with an ancilla, then measure each ancilla.
Although the errors to the qubits are actually continuous, the effect
of measuring the ancilla is to discretize the errors, as well as
inform us whether an error occurred so that it can be corrected.
\end{quote}

\paragraph*{Deferring Quantum Measurements.} The evolution of a
quantum system is deterministic. Measurement adds significant
complications, collapsing the quantum state, and producing
probabilistic results. However, using ancilla qubits, it is possible to
avoid doing any intermediate measurements in a quantum
circuit~\cite{dewolf}.

%%%
\subsection{Ancillae Bugs in Benchmarks.}
Despite its fundamental importance, the management of ancillae is
poorly supported in current languages, simulators, and toolkits.
A recent analysis of bugs in quantum
benchmarks~\cite{DBLP:conf/oopsla/HuangM18} demonstrates this. The analysis
reveals that lack of language support in the management of ancillae leads to
several problems. For example:
\begin{quote}
  \textbf{Bug type 6: Incorrect composition of operations using mirroring}
  Section~4.5 discussed how bugs in deallocating ancillary qubits can
  happen due to bad parameters. Here we see how bugs in deallocating
  ancillary qubits can happen due to incorrect composition of
  operations following a mirroring pattern. For example, in Table~7,
  the operations in rows 2 and 3 are respectively mirrored and undone
  in rows~6 and~5. These lines of code need careful reversal of every
  loop and every operation.
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[t]
\begin{multicols}{2}
\[\begin{array}{rrcll}
\idc :& \tau & \iso & \tau &: \idc \\
\\
\identlp :&  0 + \tau & \iso & \tau &: \identrp \\
\swapp :&  \tau_1 + \tau_2 & \iso & \tau_2 + \tau_1 &: \swapp \\
\assoclp :&  \tau_1 + (\tau_2 + \tau_3) & \iso & (\tau_1 + \tau_2) + \tau_3 &: \assocrp \\ [1.5ex]
\identlt :&  1 \times \tau & \iso & \tau &: \identrt \\
\swapt :&  \tau_1 \times \tau_2 & \iso & \tau_2 \times \tau_1 &: \swapt \\
\assoclt :&  \tau_1 \times (\tau_2 \times \tau_3) & \iso & (\tau_1 \times\tau_2) \times \tau_3 &: \assocrt \\ [1.5ex]
\distz :&~ 0 \times \tau & \iso & 0 ~ &: \factorzl \\
\dist :&~ (\tau_1 + \tau_2) \times \tau_3 & \iso & (\tau_1 \times \tau_3) + (\tau_2 \times \tau_3)~ &: \factor
\end{array}\]
%\vspace{2cm}
\begin{center}
\Rule{}
{\jdg{}{}{c_1 : \tau_1 \iso \tau_2} \quad \vdash c_2 : \tau_2 \iso \tau_3}
{\jdg{}{}{c_1 \fatsemi c_2 : \tau_1 \iso \tau_3}}
{}

\vspace{1cm}

\Rule{}
{\jdg{}{}{c_1 : \tau_1 \iso \tau_2} \quad \vdash c_2 : \tau_3 \iso \tau_4}
{\jdg{}{}{c_1 \oplus c_2 : \tau_1 + \tau_3 \iso \tau_2 + \tau_4}}
{}

\vspace{1cm}

\Rule{}
{\jdg{}{}{c_1 : \tau_1 \iso \tau_2} \quad \vdash c_2 : \tau_3 \iso \tau_4}
{\jdg{}{}{c_1 \otimes c_2 : \tau_1 \times \tau_3 \iso \tau_2 \times \tau_4}}
{}
\end{center}
\end{multicols}
\caption{$\Pi$-terms and combinators.}
\label{pi-terms}
\end{figure*}

\section{Preliminaries: $\Pi$}
\label{sec:pi}

The step from reversible classical circuits to quantum circuits
requires the addition of just one gate that creates
superpositions. Similarly the step from a reversible classical
programming language to a quantum one requires just the management of
superpositions. For example, starting from the classical reversible
language Theseus~\cite{james2014theseus}, a small extension produces a
quantum language with quantum
control~\cite{10.1007/978-3-319-89366-2_19}.
Theseus~\cite{james2014theseus} is a language that layers convenient
syntactic extensions over an even more basic language $\Pi$ of
combinators witnessing isomorphisms over finite
types~\cite{DBLP:conf/esop/CaretteS16}. The combinator-based language
has the advantage of being more amenable to formal analysis for at
least two reasons: (i) it is conceptually simple and small, and (ii)
it has direct and evident connections to type theory and category
theory. Indeed our solution for managing ancillae is inspired by the
construction of \emph{compact closed
  categories}~\cite{kelly1972many}. These categories extend the
monoidal
categories~\cite{benabou1963algebre,benabou1964algebre,maclane1963natural} which
are used to model many resource-aware (e.g., based on linear types) programming
languages~\cite{benton1994mixed,krishnaswami2015integrating}
(including $\Pi$) with a new type
constructor that creates duals or inverses to existing types. This
dual will be our fractional type.

%%%%%
\subsection{Core $\Pi$}
\label{sub:core}

The syntax of the language consists of several categories:
\[\begin{array}{lrcl}
\textit{Value types} & t &::=& 0 \alt 1 \alt t+t \alt t\times t \\
\textit{Values}      & v &::=& \textsf{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,v) \\
\textit{Program types} &&& t \leftrightarrow t \\
\textit{Programs} & c &::=& (\textrm{See Fig.~\ref{pi-terms}})
\end{array}\]

Focusing on finite types, the building blocks of type theory are: the
empty type ($0$), the unit type ($1$), the sum type ($+$), and the
product ($\times$) type. One may view each type $A$ as a collection of
physical wires that can transmit $|A|$ distinct values where $|A|$ is
the size of a type, computed as: $| 0 | = 0$; $| 1 | = 1$;
$| A + B | = | A | + | B |$; and $| A \times B | = | A | * | B
|$. Thus the type $\mathbb{B} = 1 + 1$ corresponds to a wire that can
transmit two values, i.e., bits, with the convention that $\inlv{\textsf{tt}}$
represents \textsf{false} and $\inrv{\textsf{tt}}$ represents
\textsf{true}. The type
$\mathbb{B} \times \mathbb{B} \times \mathbb{B}$ corresponds to a
collection of wires that can transmit three bits. From that
perspective, a type isomorphism between types $A$ and $B$ (such that
$|A|=|B|=n$) models a \emph{reversible} combinational circuit that
\emph{permutes} the $n$ different values. These type isomorphisms are
collected in Fig.~\ref{pi-terms}. It is known that these type
isomorphisms are sound and complete for all permutations on finite
types~\cite{Fiore:2004,fiore-remarks} and hence that they are
\emph{complete} for expressing combinational
circuits~\cite{fredkin1982conservative,James:2012:IE:2103656.2103667,Toffoli:1980}. Algebraically,
these types and combinators form a \emph{commutative semiring} (up to
type isomorphism). Logically they form a superstructural logic
capturing space-time tradeoffs~\cite{superstructural}. Categorically,
they form a \emph{distributive bimonoidal category}~\cite{laplaza72}.

%% Not sure about this
%% The formalization of $\Pi$ in Agda
%% \PI{}
%% And it is reversible:
%% \PIrev

%%%
\subsection{Small Examples}
\label{sub:toff}

Below, we show code that defines types corresponding to bits (booleans),
two-bits, three-bits, and four-bits. We then define an operator that
builds a controlled version of a given combinator $c$. This controlled
version takes an additional ``control'' bit and only applies $c$ if
the control bit is true. The code then iterates the control operation
several times starting from boolean negation.

\Bexamples{}

By construction, the \AgdaFunction{TOFFOLI} function takes three bits,
and negates the third if the first two are both true. As
Toffoli~\cite{Toffoli:1980} demonstrated, this function is universal
for classical reversible circuits assuming it is possible to allocate
and de-allocate ancilla bits. Indeed without using ancilla bits, it is
not possible to use compositions of \AgdaFunction{TOFFOLI} functions
to implement more general versions that are controlled by more than
two bits (for example, \AgdaFunction{CTOFFOLI}). The proof is simple:
the \AgdaFunction{TOFFOLI} function depends on two control bits and
possibly negates a third; when used in a circuit with four bits, the
unused bit can be either state, which means that
\AgdaFunction{TOFFOLI} generates an even permutation. The function
\AgdaFunction{CTOFFOLI} is however an odd permutation which is
unreachable from even permutations.
This function will however be definable using composition of
\AgdaFunction{TOFFOLI} once we introduce ancilla bits in the next section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interchangeable Ancillae}
\label{sec:dyn}

The management of ancilla data can be teased into two relatively
distinct subproblems:
\begin{itemize}
\item Every allocated ancilla bit must be de-allocated, and
\item De-allocation of an ancilla bit is only safe if the bit is
  restored to its allocation-time initial value.
\end{itemize}
In this section, we focus on the first subproblem and address the
second in later sections.

%%%%%
\subsection{Scoped Ancilla}

A conventional and efficient way to ensure that every allocation is
paired with a matching de-allocation is to impose a stack
discipline. An illustrative demonstration of this idea is the
\verb|with_ancilla| operator from
Quipper~\cite{Green:2013:QSQ:2491956.2462177} :
\begin{verbatim}
with_ancilla :: (Qubit -> Circ a) -> Circ a
\end{verbatim}
The operator takes a block of gates parameterized by an ancilla,
allocates a new ancilla of type \verb|Qubit| initialized to $\ket{0}$,
and runs the given block of gates. At the end of its execution, the
block is expected to return the ancilla to the state $\ket{0}$ (this
is the second subproblem addressed later) at which point it is
de-allocated. In this scoped-by-construction approach, allocation and
de-allocation of ancillae requires nothing beyond conventional
parameter-passing techniques in which the parameter is allocated
before entry to a function and de-allocated at exit.

This scoped model is therefore quite a pragmatic choice. It is however
limited, and to understand its limitations more vividly, we propose
the following analogy: allocating an ancilla by creating a new wire in
the circuit is like borrowing some money from a global external
entity (the memory manager); the computation has access to a new resource
temporarily. De-allocating the ancilla is like returning the borrowed
money to the global entity; the computation no longer has access to
the additional resource. It would however be unreasonably restrictive
to insist that the person (function) borrowing the money must be
the same person (function) returning it.
%% , i.e., preventing the following computation:
%% \begin{verbatim}
%%   |-----\  /-----|
%%          \/
%%         / \
%%   |----/   \-----|
%% \end{verbatim}
Indeed, as far as reversible or quantum computation is concerned, the
only important invariant is that information is conserved, i.e., that
money is conserved. The identities of bits or qubits are not
observable as they are all interchangeable in the same way that
particular bills with different serial numbers are interchangeable in
financial transactions. Thus the only invariant is that the net flow
of money between the computation and the global entity is zero. This
observation allows us to go even further than just switching the
identities of borrowers. It is even possible for one person to borrow
\$10, and have three different persons collectively collaborate to
pay back the debt with one person paying \$5, another \$2, and a third
\$3.

Computationally, this extra generality is not a gratuitous concern:
since scope is a \emph{static property} of programs, it does
not allow the flexibility of heap allocation in which the lifetime of
resources is dynamically determined. To summarize, since the
reversible-quantum computational framework guarantees that information
is preserved, it also permits fascinating mechanisms in which
allocations and de-allocations can be sliced and diced, decomposed and
recomposed, run forwards and backwards, in arbitrary ways as long as
the net balance is 0.

%%%%%
\subsection{GC Value of Fractional Type}

Instead of restricting ancillae to be scoped, we separate allocation
and de-allocation into two dual actions $\eta$ and $\epsilon$ whose
types are (almost):
\[
\eta_A : 1 \leftrightarrow A \times \oneover{A} : \epsilon_A
\]
The names and types of these operations are inspired by compact closed
categories which are extensions of the monoidal categories that model
$\Pi$. Intuitively, $\eta$ allows one from ``no information'' to
create a pair of a value of type $A$ and a value of type
$\oneover{A}$. We interpret the latter value as a gc process
specialized to collect the created value. Dually, $\epsilon$ applies
the gc process to the appropriate value annihilating
both.\footnote{Another interesting interpretation is that these
  operations correspond to creation and annihilation of entangled
  particle/antiparticle pairs in quantum
  physics~\cite{Panangaden2011}.}

To make this idea work, several technical details are needed. Most
notably, we must exclude the empty types from this creation and
annihilation process. Otherwise, we would be able to prove that:
\[\begin{array}{rcll}
1 &=& 0 \times 1/0 & \textrm{by~} \eta_0 \\
&=& 0 & \textrm{by~} \absorbr
\end{array}\]
The second important detail is to ensure that the gc process is
specialized to collect a particular value. We however defer this point to
the next section and for now create gc processes that might be applied
to incorrect values throwing exceptions instead of collecting them. We
therefore extend the syntax of core $\Pi$ in Sec.~\ref{sub:core} as
follows:

\[\begin{array}{lrcl}
\textit{Value types} & t &::=& \cdots \alt \oneover{t} \\
\textit{Non-empty types} & \net \\
\textit{Values}      & v &::=& \cdots \alt \gcv \\
\textit{Program types} &&& t \leftrightarrow t \\
\textit{Programs} & c &::=& \cdots \alt
   \eta_{\net} : 1 \leftrightarrow (\net \times \oneover{\net}) \\
   &&& ~~~~~\alt \epsilon_{\net} : (\net \times \oneover{\net}) \leftrightarrow 1
\end{array}\]

The metavariable $\net$ excludes all types that are equivalent to the
empty type, e.g., $(1 + 1) \times 0$. For now, all gc processes are
represented at runtime using a trivial value denoted by $\gcv$.

In the Agda formalization, the types of $\eta$ and $\epsilon$ are:
\EtaEpsilon{}
\noindent where the operations take an implicit argument asserting the
given type is non-empty. A \emph{big step operational semantics} for
the language interprets each combinator (except $\eta$ and $\epsilon$)
of type $t_1 \leftrightarrow t_2$ as a (reversible) function mapping
values of type $t_1$ to values of type $t_2$ (and
vice-versa).\footnote{In Sec.~\ref{sec:space} we will define a small
  step abstract machine that exposes the space used at each step.}
Extending this interpreter to handle $\eta$ and $\epsilon$ requires
that the interpreter returns either a value of the appropriate type or an
exception:

\dyninterp{}

When ancillae are created, they are created with a specific default
value depending on the type. When the gc process encounters a value to
be collected, it checks whether this value is the default value for
the type and if so collects it. Otherwise it returns
\AgdaInductiveConstructor{nothing} indicating an exception.

%%%%%
\subsection{Examples}
\label{sub:id}

The first example below illustrates the basic functionality of
ancillae. The Agda code is written in a style that reveals the
intermediate steps for easier correspondence with the figure. The
circuit has one input and one output. Immediately after receiving the
input, the circuit generates an ancilla wire and its corresponding gc
process (first two steps in the Agda definition). The original input
and the ancilla wire interact using two \AgdaFunction{CNOT} gates,
after which the ancilla wire is redirected to the output (next three
steps in the Agda code). Finally the original input is gc'ed (last two
steps in the Agda code). The entire circuit is extensionally
equivalent to the identity function but it does highlight an important
functionality beyond scoped ancillae management: the allocated ancilla
bit is redirected to the output and a completely different bit (with
the proper default value) is collected instead.

%% \medskip
\begin{center}
\input{idpic.tikz}
\end{center}

\vspace{-\baselineskip}

\EtaEpsilonExampleone{}

The second example illustrates the manipulation of gc processes. A
process for collecting a pair of values can be decomposed into two
processes each collecting one of the values (and vice-versa):

\EtaEpsilonExampletwo{}

%%%%%
\subsection{Choosing Ancillae Values: $\Pi/D$}

The previous development achieves a significant milestone but only
hints at the full expressiveness of fractional types. A small addition
that significantly increases expressiveness is to allow ancillae to be
initialized to a value of the programmer's choice, not just a globally
fixed default value. This ability is used in Grover's search algorithm
to implement phase kickback
efficiently~\cite{howgrover}.\footnote{Instead of using an ancilla bit
  initialized to $\ket{0}$, an ancilla initialized to
  $\frac{\ket{0}-\ket{1}}{\sqrt{2}}$ is used.} This can be easily
achieved by adapting our language as follows:

\[\begin{array}{lrcl}
\textit{Value types} & t &::=& \cdots \alt \oneover{v} \\
\textit{Values}      & v &::=& \cdots \alt \gcv \\
\textit{Program types} &&& t \leftrightarrow t \\
\textit{Programs} & c &::=& \cdots \alt
   \eta_{v:t} : 1 \leftrightarrow (t \times \oneover{v}) \\
   &&& ~~~~~\alt \epsilon_{v:t} : (t \times \oneover{v}) \leftrightarrow 1
\end{array}\]

We will call this language $\Pi/D$ for the fractional extension of
$\Pi$ with a dynamic check. In addition to being more expressive than
the language in the previous subsection, $\Pi/D$ has the advantage of
replacing the cumbersome cardinality-based evidence that the type is
not empty by the more intuitive evidence of choosing a value of the
type. The simplifications are evident in the Agda formalization:

\PIFDUdef{}

\vspace{-\baselineskip}

\PIFDCombdef{}

\vspace{-\baselineskip}

\PIFDinterp{}

\begin{wrapfigure}{r}{0.2\textwidth}
  \input{parity.tikz}
\end{wrapfigure}
We illustrate the new style of ancilla management with an interesting
example used in quantum circuits as a dynamic assertion of
entanglement~\cite{DBLP:journals/cal/ZhouB19}:

\PIFDparity{}

\noindent The circuit initializes the ancilla to \AgdaInductiveConstructor{true} and
checks that it remains \AgdaInductiveConstructor{true} after interacting with the two
inputs. If either one of the inputs is \AgdaInductiveConstructor{true} (but not both)
the ancilla bit will be negated and the runtime check would fail. Thus
the circuit can be used as a runtime assertion that the two inputs are
equal. When applied to quantum inputs, the circuit detects whether the
two qubits are entangled or not. By varying the initial value of the
ancilla, it is possible to customize the dynamic assertion to check
for particular entangled states~\cite{DBLP:journals/cal/ZhouB19}.

As a more substantial example, we present a construction (in
Fig.~\ref{fig:toff}) of not just the four-bit Toffoli function from
Sec.~\ref{sub:toff} but in fact an inductive construction that defines
all $n$-bit Toffoli gates. The construction goes back to Toffoli's
proof of universality~\cite{Toffoli:1980}:\\

{\centering \input{toffoli.tikz}}

Note that in the construction of \AgdaFunction{TOFFOLI‚Çô} only wire manipulating operators
(multiplicative operators), ancilla allocation / de-allocation and \AgdaFunction{TOFFOLI}
are used.

\begin{figure}[ht]
  \PIFDtoffoli{}
\caption{\label{fig:toff}Generalized Toffoli Gates}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Space-Tracking Abstract Machine}
\label{sec:space}

There are two technical reasons we are calling the new type constructor a
\emph{fractional type} and hence using for it the suggestive notation
$\oneover{t}$:
\begin{itemize}
\item Categorical: The categorical model for the plain $\Pi$ language
  of type isomorphisms is a category with two symmetric monoidal
  structures (additive and multiplicative) with the multiplicative fragment
  distributing over the additive one~\cite{DBLP:conf/esop/CaretteS16}. Generally,
  a symmetric monoidal category is \emph{compact closed} if every
  object has a dual object whose behavior is governed by our $\eta$
  and $\epsilon$ operators~\cite{kelly1972many}. Our language from the previous
  section is an adaptation of this idea to the context of $\Pi$. Many
  programming abstractions (such as \emph{name}, \emph{co-name}, and
  \emph{trace} illustrated in Sec.~\ref{sec:cat}) can be
  derived from properties of compact closed categories. Additionally,
  all the properties expected of the rational numbers
  (e.g. $\oneover{(m*n)} = \oneover{m}*\oneover{n}$,
  $\oneover{(\oneover{n})}=n$, etc.) can be given constructive content
  corresponding to manipulation of gc processes. We have already seen
  the first example and will see more in Sec.~\ref{sec:cat}.

\item Operational: The other reason our types can be justifiably
  called fractional is information theoretic. As mentioned in the
  introduction, the number of bits needed to store information about a
  space with $n$ distinct values is $\log{n}$. If the number of bits
  can be thought of as a debt (to be reclaimed) then a negative number
  of bits corresponds to a space with $\oneover{n}$ distinct
  values. Indeed we interpret these values as gc processes each
  specialized to collect space for one of the $n$ distinct values. In
  this section, we make this intuition precise by presenting a
  (fully-formalized in Agda) abstract machine that manages an explicit
  heap.
\end{itemize}

%%
\subsection{Abstract Machine for $\Pi$}

To start, we introduce some of the common technical details in the
simpler setting of the core $\Pi$ language. The cardinalities of
finite types map directly to the natural numbers. An easy proposition
to verify is that every combinator must be between types of the same
cardinalities; indeed one of the standard interpretations of $\Pi$
combinators is that they are permutations on finite sets, i.e., they
just shuffle elements around without changing the sizes of the
underlying sets:

\PIMEMcardeq{}

\vspace{-\baselineskip} 

To make the space usage explicit in every step of evaluation, we
define an abstract machine whose states are pairs of a code register
and a memory register. In a low-level implementation the code register
would contain a pointer to the current instruction and the memory
register would contain a bit-level runtime representation of values
with one bit for boolean values, etc. In the Agda formalization, we
include the current combinator in the code register, and represent the
memory register using an index into an enumeration. Thus a memory
register containing a boolean value would be represented as
\AgdaFunction{[ùîΩ ,  ùïã ][0]} or \AgdaFunction{[ùîΩ ,  ùïã ][1]} depending on whether the
value is \AgdaInductiveConstructor{false} or \AgdaInductiveConstructor{true}.
The prepended vector contains all possible values of the type and the number in between [\ldots ]
is an index into the vector, representing a finite number that
is guaranteed to be in bounds. In a low-level runtime representation
only a binary encoding of this finite type would need to be stored, but in
order to just prove that space is preserved, we can just inspect the
size of the prepended list. Putting it all together, machine states and
small-step reductions are formalized as follows:

\PIMEMstep{}

%% Note that step' uses step, but step is never shown
%% The need for the rewrite probably should be explained too.

The constructor for machine states takes a number which is the size of
the memory. This size is maintained throughout the execution,
even if the intermediate types change. As a small example, the
following is a trace of the execution of \AgdaFunction{CNOT} applied
to ùïã, ùïã:

{\center\input{trace1.tex}}

Note how the size of the vector remains equal to 4 throughout the
execution, even if the individual elements change as types change and
the current index (i.e., the current value) changes.

%% cardinality of pi type:
%% \PIMEMcard{}
%%
%% enumeration:
%% \PIMEMenum{}
%%
%%  combinator preserve size:
%% \PIMEMcardeq{}
%%
%%  semantics for Pi:
%% \PIMEMstate{}
%% \PIMEMstep{}

%%
\subsection{Abstract Machine for $\Pi/D$}

Using the same assumptions as before, machine states and small step
reductions are formalized as follows:

\PIFMEMstep{}

\vspace{-\baselineskip}

The main difference is that the state constructor does not take a
fixed size and indeed the size changes during execution as appropriate
to fit the elements of the type $A$. In particular, since fractional
values have a trivial representation, the cardinality of a fractional
type is 1, and hence $\eta$ used at type $A$ grows the size of the
memory by an $|A|$-factor. As an illustrative example,
we show a trace of the execution of \AgdaFunction{id'}
from Sec.~\ref{sub:id} applied to ùïã:

{\center\input{trace2.tex}}

%% semantics for PiFracDyn:
%% \PIFMEMstate{}
%% \PIFMEMstep{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependently-Typed Garbage Collectors}
\label{sec:dep}

By lifting the scoping restriction, the development in the previous
sections is already more general than the state of the art in ancilla
management.  It however shares the same limitation of requiring a
runtime check to ensure ancillae values are properly restored to their
allocation
value~\cite{10.1007/978-3-319-20860-2_13,Green:2013:QSQ:2491956.2462177}.
In this section, we address this limitation using a combination of
pointed types, singleton types, monads, and comonads.

%%%%%
\subsection{Lifting Evaluation to the Type System}

Before giving all the (rather involved) technical details, we
highlight the main idea using the toy language below:

\Jexample{}

\vspace{-\baselineskip}

The toy language has two types (natural numbers and booleans) and two
functions (and their compositions). Say we wanted to prove that
\AgdaInductiveConstructor{compose isZero square} always returns
\AgdaInductiveConstructor{false} when applied to a non-zero natural
number. We can certainly do this proof in Agda (i.e., in the
meta-language of our formalization) but we would like to do the proof
within the toy language itself. The most important reason is that it
can then be used within the language to optimize programs (or, for the
case of $\Pi/D$ to remove a runtime check).

The strategy we adopt is to create a lifted version of the toy
language with \emph{pointed types}~\cite{hottbook}, i.e., types paired with
a value of the type. In the lifted language, the evaluation
function has an interesting type: it keeps track of the result of
evaluation within the type:

\Jexamplecont{}

\vspace{-\baselineskip}
 
Various properties of
\AgdaInductiveConstructor{compose isZero square} can be derived within
the extended type system:

\Jexampletest{}

We can track concrete values as the first two tests
show. More interesting is \AgdaFunction{test3} which shows a
property that holds for all natural numbers $n$. Evaluation
proceeds ``symbolically'' in the type system. From the definition
of \Afun{eval}, it is clear that
\Afun{eval}~\Acon{square}~(\Acon{suc}~\Avar{n}) produces
(\Acon{suc}~\Avar{n}) * (\Acon{suc}~\Avar{n}) which by definition of
multiplication is an expression with a leading \Acon{suc} constructor
which is enough to determine that evaluating
\Acon{isZero} on it yields \Acon{false}. This form of partial
evaluation will prove to be quite expressive, allowing us to keep track
of ancillae values throughout complex programs.

%%%%%
\subsection{Pointed and Singleton Types: $\Pi/\bullet$}

Proceeding similarly, we create a
version of $\Pi$ with pointed types which we call
$\Pi/\bullet$. In addition to the pointed types of the form
$t$\Acon{\#}$v$, we need a multiplicative structure over pointed
types, fractional types, and a special kind of pointed type that
includes just one value, a singleton type. The singleton types will
allow the type system to track the flow of one particular value, which
is exactly what is needed to prove the safety of deallocation:

\PIPFUdef{}

As can be seen, a lifted type is interpreted as a type along with a
corresponding value. A singleton type consists a special value of a
given type: any claim that a value belongs to the singleton type must
come with a proof that this value is equivalent to the special
value. A fractional type consumes a particular singleton type
returning the unit type. Note that the runtime gc process simply
disregards the value it is given: the type system however prevents
this value from being applied to anything but the particular singleton
value in question.

The combinators in the lifted language $\Pi/\bullet$ consist of all the combinators
in the core $\Pi$ language but now operating on pointed types. The mediation
between general pointed types and singleton types is done via
\Acon{return} and \Acon{extract}, which as we prove below form a
dual monad/comonad pair. The types for \Acon{$\eta$} and
\Acon{$\epsilon$} are now specialized to guarantee safety of
de-allocation as follows. When applying \Acon{$\eta$} at a pointed type, the
current witness value is put in focus in a singleton type and a gc
process for that particular singleton type is created. To apply this
process using \Acon{$\epsilon$} the very same singleton value must be
the current one.

\PIPFCombDef{}

The mediation between pointed and singleton types is based on a dual
monad/comonad pair from which many structural properties can be
derived.

\begin{proposition}
  $\llparenthesis \cdot \rrparenthesis$ is both an idempotent strong
  monad and an idempotent costrong comonad over pointed types.
\end{proposition}
\begin{proof}
  The main insight needed is to define the functor \Afun{‚àôSing·µ§}, the
  \Afun{tensor}/\Afun{cotensor}, and the \Afun{join}/\Afun{cojoin}
  (\Afun{duplicate}):
\PIPFCombderive{}
\end{proof}

Like for the toy language, evaluation is reflected in the type
system, and in this case we have the additional property that
evaluation is reversible:

\PIPFeval{}

\vspace{-\baselineskip}

\PIPFrev{}

Thus, to summarize, if a combinator expects a singleton type, then it
would only typecheck in the lifted language, if it is given the unique
value it expects. A particularly intriguing instance of that
situation is the following program:

\begin{center}
\input{revrev.tikz}
\end{center}

\PIPFrevrev{}

The program takes a value of type
\Acon{‚àôùüô/}~(\Acon{‚àôùüô/}~\Avar{A}). This would be a gc process
specialized to collect another gc process! At runtime, there would
be no information other than the functions that ignore their argument
but the type system provides enough guarantees to ensure that this
process is well-defined and safe. The following
trace shows the actual execution for confirmation:

{\center\input{trace3.tex}}

As the trace shows, by garbage collecting the collector for value
$\mathbb{T}$, this value which was maintained in the type is now
``rematerialized.''

%%%%%%%%%
\subsection{Extraction}

By lifting programs and their evaluation to the type level, we can
naturally leverage the typechecking process to verify properties of
interest, including the safe de-allocation of ancillae. One ``could''
just forget about $\Pi/D$ and instead use $\Pi/\bullet$ as \emph{the}
programming language for ancilla management. Indeed the dual nature of
proofs and programs is more and more exploited in languages like the
one used to formalize this paper (Agda). The examples in
Sec.~\ref{sec:cat} are written in that style and they are relatively
similar to programs in the ``normal'' $\Pi/D$ language.

However, it is also often the case than constructive proofs are
further processed to extract native efficient programs that eschew
the overhead of maintaining information needed just for proof
invariants. In our case, the question is whether we can extract from
a $\Pi/\bullet$ program, a program in $\Pi/D$ that uses a simpler type
system, a simpler runtime representation, and yet is guaranteed to be
safe and hence can run without the runtime checks associated with
de-allocation sites. In this section, we show that this indeed the
case.

% First we can inject plain Pi type and value into PiFracDyn:
% %% \ednote{Pi/.U is not defined before its use below}
% \INJU{}
% and the combinators for Pi can also be inject into PiFracDyn in a straightforward way:
% \INJcomb{}
% The given injection is correct because it does not change the denotation of type
% \INJUeq{}
% ,the value
% \INJVeq{}
% and the interpretation of PiFracDyn is consistent with Pi:
% \INJEvaleq{}

The extraction map is fully implemented in the underlying Agda
formalization. We present the most significant highlights. Here are
three important functions' signatures:

\EXTsig{}

\vspace{-\baselineskip}

\noindent The function \Afun{Extùïå} maps a $\Pi/\bullet$ type to a $\Pi/D$ type
and a value in the type. The function \Afun{Ext‚àô‚ü∂} maps a
$\Pi/\bullet$ combinator to a $\Pi/D$ combinator. And finally the
function \Afun{Ext‚â°} asserts that extracted code cannot throw an
exception (it must return \Acon{just}\ldots).

Each of these functions has one or two enlightening cases which we
explain. 

In $\Pi/D$ the fractional type expresses that it expects a particular
value but lacks any mechanisms to enforce this requirement. Thus we
have no choice when mapping a fractional type from $\Pi/\bullet$ to
$\Pi/D$ than to just use this \Acon{ùüô/}~\Avar{v} ~type:

\EXTu{}

% There is no corresponding type of Recip
% in plain Pi, but we can map it to the
% \AgdaOperator{\AgdaInductiveConstructor{ùüô/}}\AgdaSpace{}\AgdaBound{v}
% type in PiFracDyn.  Note that for all other type the extracted value
% is erased from type except for
% \AgdaOperator{\AgdaInductiveConstructor{ùüô/}}\AgdaSpace{}\AgdaBound{v}
% which we still keep it in type.

When mapping $\Pi/\bullet$ combinators to
$\Pi/D$ combinators, the main interesting cases are for \Acon{Œ∑} and
\Acon{Œµ}. In those, we just use the values from the pointed type as
choices for the ancilla value and expectation for the gc process:

\EXTcomb{}

% Once we extract the
% corresponding type we can extract the combinator, the combinators
% about monad/comonad just becomes \AgdaInductiveConstructor{id‚Üî} since
% the information in type is erased, for the rest combinators there
% exist direct corresponding combinators in PiFracDyn:

% Finally we can prove the correctness of the extraction, the lifted
% multiplicative combinators have the corresponding combinators in
% PiFracDyn which represent the same computation so the proof is just
% \AgdaInductiveConstructor{refl}.  Because the combinators about
% monad/comonad does not really computes so for those case the proof is
% also \AgdaInductiveConstructor{refl}.  And for
% \AgdaInductiveConstructor{‚àôc} we rely on \AgdaFunction{Eval‚â°}.  The
% interesting case is \AgdaInductiveConstructor{Œµ} where the singleton
% type guarantee that the dynamic check won't fail.

Finally we can prove the correctness of the extraction. The punchline
is in the following case:

\EXTeq{}

\noindent In this case, the singleton type in $\Pi/\bullet$ guarantees that the
runtime check cannot fail.

%%%%%%%%%%%
\subsection{Examples}
\label{sec:cat}

In addition to the examples presented throughout the paper, we present
examples that provide novel perspectives on gc processes, first as
space transformers, and second as tracing operators. Both ideas are
inspired from known constructions in compact closed
categories~\cite{dblp:conf/calco/abramsky05}.

\paragraph*{Space Transformers.} A pair of a value and a gc process
cancel each other when the gc process is expecting this particular
value. In more general cases, the pair can be viewed as a space
transformer that represents an implicit function that converts the value to the
one expected by the gc process. Such space transformers can be
composed and applied.

\PPFThof{}

\paragraph*{Tracing Operators.} Another intriguing abstraction is
based on the fact that dual objects can be used to define a tracing
operator:

\PPFTtrace{}

The operator takes a function that expects a pair of inputs $A$ and
$C$ and returns a pair of outputs $B$ and $C$. In the world of
reversible programs (or permutations), the larger permutation
guarantees the existence of a smaller permutation that permutes $A$ to
$B$. Indeed, we can programmatically construct such a permutation:

As the diagram below (taken from Abramsky's
paper~\cite{dblp:conf/calco/abramsky05}) illustrates, this is not a
trivial construction in the sense that the permutation from $A$ to $B$
uses $C$ in non-trivial ways.

\includegraphics[scale=0.5]{trace.png}

Interpreted in our setting, the program can be written as follows:

\PPFTtraceex{}

The feedback loop in the diagram is realized using ancillae allocation
and de-allocation. The safety condition on de-allocation ensures that
the allocated value (now in the feedback loop) matches the
de-allocated value. Thus, the entire traced component is treated as an
ancilla value used internally to perform the larger program but
leaving no memory footprint.

%% SAT solver ??
%% in-place matrix transpose

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work and Conclusion}

We have introduced, in the context of reversible/quantum languages,
the concept of fractional types as descriptions of specialized gc
processes. Although the basic idea is rather simple and intuitive, the
technical details needed to reason about individual values are
somewhat intricate. 

There has been ample work on ancillae before us.  For example
\cite{PhysRevA.94.042337} explicitly represents the lifetime of
quantum wires, enabling quantum wires to be recycled, leading
to more efficient circuits.  Interesting applications of
ancillae is in the recent paper~\cite{DBLP:journals/cal/ZhouB19}
on quantum runtime assertions.  In section~\ref{sub:id}, we
already mentioned dynamic assertion of entanglement; they
also show how to provide (dynamic) assertions on classical
states, and testing of superposition states.  Our techniques
should combine with theirs to provide even more possibilities
for dynamic assertions. Ancilla management is a complex
business, and the verified circuit compiler
ReVerC~\cite{amy2017verified} goes to great pains to
ensure that ancilla are dealt with properly.  Both
QCL~\cite{omer2002procedural} and Quipper~\cite{Green:2013:QSQ:2491956.2462177}
also do automatic (but not certified) ancilla management during code
generation.  This remains an active area of research, as
outlined in the CACM paper~\cite{valiron2015programming}.

Another interesting avenue is to understand how to merge $\Pi/\bullet$
with other languages for quantum
computing~\cite{dblp:journals/mscs/selingerv06,vantonder:2004,dowek2017lineal}. One
particular language, QWIRE~\cite{Paykin:2017:QCL:3009837.3009894}, has
a paradigm that appears eminently compatible to ours and has many
desirable meta-properties that have been formally proven to hold.
QWIRE however has an unguarded \texttt{discard} directive that may
lead to erroneous circuits. For example, their circuit reversing
operation is partial, whereas ours is provably total.

When looking at higher-level reversible languages, Janus
comes to mind~\cite{lutz1982janus}.  More recently, \cite{Yokoyama:2008:PRP}
shows how to do clean, i.e. \emph{garbage free} computation. It
would certainly be intriguing to augment Janus with a certified
garbage collection discipline such as ours, so that one might hope
that the resulting computations might be more efficiently done.

Another different thread of work stems from categorical models
of quantum computation, especially those based on dagger
compact closed categories as introduced
in~\cite{Abramsky:2004:CSQ:1018438.1021878}, and greatly
expanded upon
in~\cite{abramsky2009categorical,selinger2007dagger,Selinger:2011:FDH:1942319.1942398}, or more
recently in~\cite{DBLP:conf/lics/HuotS19}. Various
results can be obtained in that general setting, such as the
no-cloning theorem~\cite{abramsky2009no}. The $2016$ book
\cite{chiribella2016quantum} is a good survey of the
developments since. Of particular
note for our applications are two 2005 papers by Abramsky
\cite{abramsky2005structural,dblp:conf/calco/abramsky05}
with explicit examples of circuits using trace that are very useful tests
for our approach.

%Trace as a lens? This basically says, in the language of Lens, that
%when $A$ is isomorphic to $X \times Y$ and $B$ is isomorphic to
%$Z \times Y$, then $X$ is isomorphic to $Y$. Another way to think of
%it: for all isomorphic $A$ and $B$, whenever they can be factored with
%a common complement ($Y$), then the ``other pieces'' (here $X$ and
%$Y$) are automatically isomorphic.

%Positive rational numbers are a model. Apparently there is a
%categorification
%\url{https://alistairsavage.ca/pubs/Copelli-Categorification_of_the_Nonnegative_Rational_Numbers.pdf}

% General allocation and de-allocation. No need to keep track of
% lifetime. Just make sure location is back to initial value. Safe to
% de-allocate because indistinguishable from freshly created. No pointer
% equality and aliases though. Concurrent: one thread allocates; gc
% thread meets someone else

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{../cites.bib}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
